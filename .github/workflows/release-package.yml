name: Release Package

on:
  workflow_dispatch:
    inputs:
      package:
        description: 'Package name to release (e.g., @irfanandriansyah1997/compiler)'
        required: true
        type: string
      type:
        description: 'Version bump type'
        required: true
        type: choice
        default: 'minor'
        options:
          - patch
          - minor
          - major

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_BOT_RELEASE_TOKEN }}

      - name: Set git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Create .npmrc
        run: |
          rm -rf ~/.npmrc
          echo "auto-install-peers=true > ~/.npmrc"
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.GH_BOT_RELEASE_TOKEN }}" >> ~/.npmrc
          echo "@tiket:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "@irfanandriansyah1997:registry=https://npm.pkg.github.com" >> ~/.npmrc

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run Release
        id: run-release
        run: pnpm release -p "${{ inputs.package }}" --type "${{ inputs.type }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_BOT_RELEASE_TOKEN }}

      - name: Get released version and find previous tag
        id: get-version
        run: |
          # Extract the package directory from the package name
          PACKAGE_NAME="${{ inputs.package }}"
          # Find the package.json for this package
          PACKAGE_PATH=$(pnpm list -r --json --depth -1 | jq -r --arg name "$PACKAGE_NAME" '.[] | select(.name == $name) | .path')
          if [ -n "$PACKAGE_PATH" ]; then
            VERSION=$(jq -r '.version' "$PACKAGE_PATH/package.json")
            TAG_NAME="${PACKAGE_NAME}@${VERSION}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Package: $PACKAGE_NAME"
            echo "ðŸ“Œ Version: $VERSION"
            echo "ðŸ·ï¸  Tag: $TAG_NAME"
            
            # Find previous tag for this package (excluding beta tags)
            # Pattern: @scope/package@X.Y.Z (without -beta-)
            PREVIOUS_TAG=$(git tag -l "${PACKAGE_NAME}@*" | grep -v '\-beta\-' | sort -V | tail -2 | head -1)
            
            # If current tag equals previous tag (first release), set to empty
            if [ "$PREVIOUS_TAG" = "$TAG_NAME" ] || [ -z "$PREVIOUS_TAG" ]; then
              echo "â„¹ï¸ No previous release tag found for $PACKAGE_NAME"
              echo "previous_tag=" >> $GITHUB_OUTPUT
            else
              echo "ðŸ“Œ Previous tag: $PREVIOUS_TAG"
              echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Could not find package path for $PACKAGE_NAME"
            exit 1
          fi

      - name: Create release note
        id: create-release-note
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_BOT_RELEASE_TOKEN }}
          script: |
            const tagName = '${{ steps.get-version.outputs.tag_name }}';
            const previousTag = '${{ steps.get-version.outputs.previous_tag }}';
            const packageName = '${{ inputs.package }}';
            const version = '${{ steps.get-version.outputs.version }}';
            
            let releaseNotes = '';
            
            if (previousTag) {
              // Generate release notes from previous tag
              try {
                const { data: notesData } = await github.rest.repos.generateReleaseNotes({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tagName,
                  previous_tag_name: previousTag
                });
                releaseNotes = notesData.body;
                console.log(`ðŸ“ Generated release notes from ${previousTag} to ${tagName}`);
              } catch (error) {
                console.log(`âš ï¸ Could not generate notes: ${error.message}`);
                releaseNotes = `## What's Changed\n\nRelease ${version} of ${packageName}`;
              }
            } else {
              // First release - simple notes
              releaseNotes = `## ðŸŽ‰ Initial Release\n\nFirst release of **${packageName}** version ${version}`;
            }
            
            // Create the release
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `${packageName} v${version}`,
              body: releaseNotes,
              draft: false,
              prerelease: false
            });
            
            console.log(`âœ… Created release: ${release.html_url}`);
            core.setOutput('release_url', release.html_url);

      - name: Summary
        run: |
          echo "## ðŸš€ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Package:** ${{ inputs.package }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.get-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ inputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ steps.get-version.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Tag:** ${{ steps.get-version.outputs.previous_tag || 'N/A (first release)' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** ${{ steps.create-release-note.outputs.release_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Release created! The publish workflow will be triggered automatically." >> $GITHUB_STEP_SUMMARY

